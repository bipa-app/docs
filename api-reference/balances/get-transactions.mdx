---
title: "List Transactions"
description: "List all balance-affecting operations for a customer."
api: "GET https://api.bipa.tech/v1/customers/{customer_id}/transactions"
---

## Request

Retrieve all balance-affecting operations for a customer. This endpoint returns the full underlying objects (quotes, Pix transactions, on-chain transfers) in a unified timeline.

### Path parameters

<ParamField path="customer_id" type="string" required>
  The customer ID to retrieve transactions for
</ParamField>

### Query parameters

<ParamField query="limit" type="integer" default="20">
  Number of transactions to return (1-100)
</ParamField>

<ParamField query="starting_after" type="string">
  Cursor for pagination. Use the `id` of the last item from the previous page.
</ParamField>

<ParamField query="ending_before" type="string">
  Cursor for reverse pagination.
</ParamField>

<ParamField query="type" type="string">
  Filter by transaction type: `quote`, `pix_inbound`, `pix_outbound`, `onchain_inbound`, `onchain_outbound`
</ParamField>

<ParamField query="created_after" type="string">
  Filter transactions created after this ISO 8601 timestamp
</ParamField>

<ParamField query="created_before" type="string">
  Filter transactions created before this ISO 8601 timestamp
</ParamField>

## Response

Returns a list of transaction objects. Each object includes a `type` field that indicates the kind of transaction, and the `id` field contains the identifier for that specific object type.

<ResponseField name="object" type="string">
  Always `list`
</ResponseField>

<ResponseField name="data" type="array">
  Array of transaction objects (quote, pix, or onchain transfer objects)
</ResponseField>

<ResponseField name="has_more" type="boolean">
  Whether more results exist
</ResponseField>

<ResponseField name="total_count" type="integer">
  Total number of transactions matching filters
</ResponseField>

## Transaction types

Each transaction includes a `type` field that determines the structure of the object:

| Type | ID prefix | Description |
|------|-----------|-------------|
| `quote` | `quote_` | Executed quote (trade) |
| `pix_inbound` | `pix_` | Incoming Pix payment |
| `pix_outbound` | `pix_` | Outgoing Pix payout |
| `onchain_inbound` | `txn_` | Incoming on-chain transfer |
| `onchain_outbound` | `txn_` | Outgoing on-chain transfer |

<RequestExample>
```bash cURL
# List all transactions
curl "https://api.bipa.tech/v1/customers/cus_a1b2c3d4e5f6/transactions?limit=20" \
  -H "X-API-Key: bipa_prod_..."

# Get only trades (executed quotes)
curl "https://api.bipa.tech/v1/customers/cus_a1b2c3d4e5f6/transactions?type=quote" \
  -H "X-API-Key: bipa_prod_..."

# Get Pix activity
curl "https://api.bipa.tech/v1/customers/cus_a1b2c3d4e5f6/transactions?type=pix_inbound" \
  -H "X-API-Key: bipa_prod_..."

# Get on-chain transfers
curl "https://api.bipa.tech/v1/customers/cus_a1b2c3d4e5f6/transactions?type=onchain_outbound" \
  -H "X-API-Key: bipa_prod_..."
```

```python Python
import requests
from decimal import Decimal

def to_human(amount: str, decimals: int) -> Decimal:
    return Decimal(amount) / Decimal(10 ** decimals)

# Get transaction history
response = requests.get(
    "https://api.bipa.tech/v1/customers/cus_a1b2c3d4e5f6/transactions",
    headers={"X-API-Key": "bipa_prod_..."},
    params={"limit": 50}
)

result = response.json()
print(f"Found {result['total_count']} transactions\n")

for txn in result["data"]:
    txn_type = txn["type"]

    if txn_type == "quote":
        from_amt = to_human(txn["from_amount"], txn["from_decimals"])
        to_amt = to_human(txn["to_amount"], txn["to_decimals"])
        print(f"{txn['created_at'][:10]} | Trade: {from_amt} {txn['from_asset']} → {to_amt} {txn['to_asset']}")

    elif txn_type in ["pix_inbound", "pix_outbound"]:
        amount = to_human(txn["amount"], txn["decimals"])
        direction = "received" if txn_type == "pix_inbound" else "sent"
        print(f"{txn['created_at'][:10]} | Pix {direction}: R$ {amount:.2f} ({txn['counterparty']['name']})")

    elif txn_type in ["onchain_inbound", "onchain_outbound"]:
        amount = to_human(txn["amount_net"], txn["decimals"])
        direction = "received" if txn_type == "onchain_inbound" else "sent"
        print(f"{txn['created_at'][:10]} | {txn['asset']} {direction}: {amount} on {txn['network']}")
```

```javascript Node.js
function toHuman(amount, decimals) {
  return Number(BigInt(amount)) / 10 ** decimals;
}

const response = await fetch(
  "https://api.bipa.tech/v1/customers/cus_a1b2c3d4e5f6/transactions?limit=20",
  {
    headers: { "X-API-Key": "bipa_prod_..." }
  }
);

const { data: transactions, total_count } = await response.json();
console.log(`Total transactions: ${total_count}\n`);

for (const txn of transactions) {
  const date = txn.created_at.slice(0, 10);

  switch (txn.type) {
    case "quote":
      const fromAmt = toHuman(txn.from_amount, txn.from_decimals);
      const toAmt = toHuman(txn.to_amount, txn.to_decimals);
      console.log(`${date} | Trade: ${fromAmt} ${txn.from_asset} → ${toAmt} ${txn.to_asset}`);
      break;

    case "pix_inbound":
    case "pix_outbound":
      const pixAmt = toHuman(txn.amount, txn.decimals);
      const pixDir = txn.type === "pix_inbound" ? "received" : "sent";
      console.log(`${date} | Pix ${pixDir}: R$ ${pixAmt.toFixed(2)} (${txn.counterparty.name})`);
      break;

    case "onchain_inbound":
    case "onchain_outbound":
      const onchainAmt = toHuman(txn.amount_net, txn.decimals);
      const onchainDir = txn.type === "onchain_inbound" ? "received" : "sent";
      console.log(`${date} | ${txn.asset} ${onchainDir}: ${onchainAmt} on ${txn.network}`);
      break;
  }
}
```
</RequestExample>

<ResponseExample>
```json 200 OK
{
  "object": "list",
  "data": [
    {
      "type": "quote",
      "id": "quote_abc123xyz",
      "customer_id": "cus_a1b2c3d4e5f6",
      "status": "executed",
      "from_asset": "BRL",
      "to_asset": "BTC",
      "from_amount": "100000",
      "to_amount": "24628",
      "from_decimals": 2,
      "to_decimals": 8,
      "price": "40200000",
      "price_decimals": 2,
      "fees": {
        "total": "1000",
        "total_bps": 100,
        "partner": "500",
        "partner_bps": 50,
        "bipa": "500",
        "bipa_bps": 50
      },
      "created_at": "2024-01-15T10:30:00Z",
      "executed_at": "2024-01-15T10:30:01Z"
    },
    {
      "type": "pix_inbound",
      "id": "pix_def456abc",
      "customer_id": "cus_a1b2c3d4e5f6",
      "direction": "inbound",
      "amount": "150000",
      "fee": "0",
      "decimals": 2,
      "status": "completed",
      "counterparty": {
        "name": "João Silva",
        "document": "***123***",
        "bank_account": {
          "ispb_code": "00000000",
          "branch_number": "0001",
          "account_number": "12345678",
          "account_type": "checking"
        }
      },
      "end_to_end_id": "E00000000202401150930abc123def456",
      "qr_code_id": "pix_static_qr_xyz789",
      "created_at": "2024-01-15T09:30:00Z",
      "completed_at": "2024-01-15T09:30:02Z"
    },
    {
      "type": "pix_outbound",
      "id": "pix_ghi789def",
      "customer_id": "cus_a1b2c3d4e5f6",
      "direction": "outbound",
      "amount": "50000",
      "fee": "0",
      "decimals": 2,
      "status": "completed",
      "counterparty": {
        "name": "Maria Santos",
        "document": "***456***",
        "pix_key": "maria@email.com",
        "bank_account": {
          "ispb_code": "00416968",
          "branch_number": "0001",
          "account_number": "87654321",
          "account_type": "checking"
        }
      },
      "description": "Payment for services",
      "end_to_end_id": "E00000000202401151000def456ghi789",
      "idempotency_key": "pay_order_12345",
      "created_at": "2024-01-15T10:00:00Z",
      "completed_at": "2024-01-15T10:00:03Z"
    },
    {
      "type": "onchain_inbound",
      "id": "txn_jkl012mno",
      "customer_id": "cus_a1b2c3d4e5f6",
      "direction": "inbound",
      "asset": "USDT",
      "network": "polygon",
      "amount_gross": "100000000",
      "amount_net": "100000000",
      "fee": "0",
      "decimals": 6,
      "status": "confirmed",
      "address": "0x1234567890abcdef1234567890abcdef12345678",
      "tx_hash": "0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890",
      "confirmations": 128,
      "confirmations_required": 128,
      "created_at": "2024-01-14T15:00:00Z",
      "confirmed_at": "2024-01-14T15:05:00Z"
    },
    {
      "type": "onchain_outbound",
      "id": "txn_pqr345stu",
      "customer_id": "cus_a1b2c3d4e5f6",
      "direction": "outbound",
      "asset": "BTC",
      "network": "bitcoin",
      "amount_gross": "1005000",
      "amount_net": "1000000",
      "fee": "5000",
      "decimals": 8,
      "status": "confirmed",
      "destination_address": "bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh",
      "tx_hash": "f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16",
      "confirmations": 6,
      "confirmations_required": 3,
      "idempotency_key": "withdraw_btc_001",
      "created_at": "2024-01-13T12:00:00Z",
      "confirmed_at": "2024-01-13T12:45:00Z"
    }
  ],
  "has_more": true,
  "total_count": 156
}
```
</ResponseExample>

## Working with different transaction types

Since each transaction type has different fields, use the `type` field to determine how to process each object:

```typescript
interface QuoteTransaction {
  type: "quote";
  id: string;
  from_asset: string;
  to_asset: string;
  from_amount: string;
  to_amount: string;
  from_decimals: number;
  to_decimals: number;
  // ... other quote fields
}

interface PixTransaction {
  type: "pix_inbound" | "pix_outbound";
  id: string;
  amount: string;
  decimals: number;
  counterparty: {
    name: string;
    document: string;
    pix_key?: string;
  };
  // ... other pix fields
}

interface OnchainTransaction {
  type: "onchain_inbound" | "onchain_outbound";
  id: string;
  asset: string;
  network: string;
  amount_gross: string;
  amount_net: string;
  fee: string;
  decimals: number;
  // ... other onchain fields
}

type Transaction = QuoteTransaction | PixTransaction | OnchainTransaction;

function processTransaction(txn: Transaction) {
  switch (txn.type) {
    case "quote":
      // Access quote-specific fields
      console.log(`Trade: ${txn.from_asset} → ${txn.to_asset}`);
      break;

    case "pix_inbound":
    case "pix_outbound":
      // Access pix-specific fields
      console.log(`Pix with ${txn.counterparty.name}`);
      break;

    case "onchain_inbound":
    case "onchain_outbound":
      // Access onchain-specific fields
      console.log(`${txn.asset} on ${txn.network}`);
      break;
  }
}
```

## Building a unified ledger

Calculate running balances across all transaction types:

```python
from decimal import Decimal
from collections import defaultdict

def build_ledger(customer_id: str):
    """Build a unified ledger from transaction history."""
    transactions = []
    starting_after = None

    # Fetch all transactions
    while True:
        params = {"limit": 100}
        if starting_after:
            params["starting_after"] = starting_after

        response = requests.get(
            f"https://api.bipa.tech/v1/customers/{customer_id}/transactions",
            headers={"X-API-Key": "bipa_prod_..."},
            params=params
        ).json()

        transactions.extend(response["data"])

        if not response["has_more"]:
            break
        starting_after = response["data"][-1]["id"]

    # Sort by date (oldest first)
    transactions.sort(key=lambda x: x["created_at"])

    # Track balances per asset
    balances = defaultdict(Decimal)
    ledger_entries = []

    for txn in transactions:
        entries = []

        if txn["type"] == "quote":
            # Quote creates two entries: debit from_asset, credit to_asset
            from_dec = txn["from_decimals"]
            to_dec = txn["to_decimals"]
            from_amt = Decimal(txn["from_amount"]) / Decimal(10 ** from_dec)
            to_amt = Decimal(txn["to_amount"]) / Decimal(10 ** to_dec)

            balances[txn["from_asset"]] -= from_amt
            balances[txn["to_asset"]] += to_amt

            entries.append({
                "date": txn["created_at"],
                "type": "quote",
                "id": txn["id"],
                "asset": txn["from_asset"],
                "debit": from_amt,
                "credit": Decimal(0),
                "balance": balances[txn["from_asset"]]
            })
            entries.append({
                "date": txn["created_at"],
                "type": "quote",
                "id": txn["id"],
                "asset": txn["to_asset"],
                "debit": Decimal(0),
                "credit": to_amt,
                "balance": balances[txn["to_asset"]]
            })

        elif txn["type"] in ["pix_inbound", "pix_outbound"]:
            decimals = txn["decimals"]
            amount = Decimal(txn["amount"]) / Decimal(10 ** decimals)

            if txn["type"] == "pix_inbound":
                balances["BRL"] += amount
                entries.append({
                    "date": txn["created_at"],
                    "type": txn["type"],
                    "id": txn["id"],
                    "asset": "BRL",
                    "debit": Decimal(0),
                    "credit": amount,
                    "balance": balances["BRL"]
                })
            else:
                balances["BRL"] -= amount
                entries.append({
                    "date": txn["created_at"],
                    "type": txn["type"],
                    "id": txn["id"],
                    "asset": "BRL",
                    "debit": amount,
                    "credit": Decimal(0),
                    "balance": balances["BRL"]
                })

        elif txn["type"] in ["onchain_inbound", "onchain_outbound"]:
            asset = txn["asset"]
            decimals = txn["decimals"]
            amount_gross = Decimal(txn["amount_gross"]) / Decimal(10 ** decimals)

            if txn["type"] == "onchain_inbound":
                balances[asset] += amount_gross
                entries.append({
                    "date": txn["created_at"],
                    "type": txn["type"],
                    "id": txn["id"],
                    "asset": asset,
                    "debit": Decimal(0),
                    "credit": amount_gross,
                    "balance": balances[asset]
                })
            else:
                balances[asset] -= amount_gross
                entries.append({
                    "date": txn["created_at"],
                    "type": txn["type"],
                    "id": txn["id"],
                    "asset": asset,
                    "debit": amount_gross,
                    "credit": Decimal(0),
                    "balance": balances[asset]
                })

        ledger_entries.extend(entries)

    return ledger_entries

# Build and print ledger
ledger = build_ledger("cus_a1b2c3d4e5f6")

print(f"{'Date':<12} {'Type':<18} {'Asset':<6} {'Debit':>12} {'Credit':>12} {'Balance':>12}")
print("-" * 72)

for entry in ledger:
    print(f"{entry['date'][:10]:<12} {entry['type']:<18} {entry['asset']:<6} "
          f"{str(entry['debit']) if entry['debit'] else '':>12} "
          f"{str(entry['credit']) if entry['credit'] else '':>12} "
          f"{entry['balance']:>12}")
```

## Fetching a specific transaction

Use the transaction `id` and `type` to fetch fresh details from the appropriate API:

```python
def get_transaction_details(txn_type: str, txn_id: str) -> dict:
    """Fetch full details for a transaction by type and ID."""
    headers = {"X-API-Key": "bipa_prod_..."}
    base_url = "https://api.bipa.tech/v1"

    if txn_type == "quote":
        # Quotes are returned in full from transactions endpoint
        # For individual quote lookup, you'd query by ID if such endpoint exists
        return None

    elif txn_type in ["pix_inbound", "pix_outbound"]:
        response = requests.get(f"{base_url}/pix/{txn_id}", headers=headers)
        return response.json()

    elif txn_type in ["onchain_inbound", "onchain_outbound"]:
        response = requests.get(f"{base_url}/onchain/transfers/{txn_id}", headers=headers)
        return response.json()

    return None
```

## Export to CSV

```python
import csv
from io import StringIO
from decimal import Decimal

def export_transactions_csv(customer_id: str) -> str:
    """Export transactions to CSV format."""
    transactions = []
    starting_after = None

    while True:
        params = {"limit": 100}
        if starting_after:
            params["starting_after"] = starting_after

        response = requests.get(
            f"https://api.bipa.tech/v1/customers/{customer_id}/transactions",
            headers={"X-API-Key": "bipa_prod_..."},
            params=params
        ).json()

        transactions.extend(response["data"])

        if not response["has_more"]:
            break
        starting_after = response["data"][-1]["id"]

    output = StringIO()
    writer = csv.writer(output)
    writer.writerow(["Date", "Type", "ID", "Asset", "Amount", "Fee", "Status", "Description"])

    for txn in transactions:
        if txn["type"] == "quote":
            writer.writerow([
                txn["created_at"],
                "quote",
                txn["id"],
                f"{txn['from_asset']}→{txn['to_asset']}",
                f"-{txn['from_amount']} / +{txn['to_amount']}",
                txn["fees"]["total"],
                txn["status"],
                f"Trade {txn['from_asset']} to {txn['to_asset']}"
            ])
        elif txn["type"] in ["pix_inbound", "pix_outbound"]:
            writer.writerow([
                txn["created_at"],
                txn["type"],
                txn["id"],
                "BRL",
                txn["amount"],
                txn["fee"],
                txn["status"],
                txn.get("description", f"Pix with {txn['counterparty']['name']}")
            ])
        elif txn["type"] in ["onchain_inbound", "onchain_outbound"]:
            writer.writerow([
                txn["created_at"],
                txn["type"],
                txn["id"],
                txn["asset"],
                txn["amount_net"],
                txn["fee"],
                txn["status"],
                f"{txn['asset']} on {txn['network']}"
            ])

    return output.getvalue()

# Export and save
csv_data = export_transactions_csv("cus_a1b2c3d4e5f6")
with open("transactions.csv", "w") as f:
    f.write(csv_data)
```
